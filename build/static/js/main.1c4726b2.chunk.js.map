{"version":3,"sources":["constants.js","App.js","useInterval.js","index.js"],"names":["CANVAS_SIZE","SNAKE_START","APPLE_START","DIRECTIONS","38","40","37","39","App","canvasRef","useRef","useState","snake","setSnake","apple","setApple","dir","setDir","speed","setSpeed","gameOver","setGameOver","callback","delay","savedCallback","useEffect","current","id","setInterval","clearInterval","useInterval","gameLoop","createApple","map","_a","i","Math","floor","random","checkCollision","piece","snk","segment","snakeCopy","JSON","parse","stringify","newSnakeHead","checkSnakeHead","unshift","newSnake","newApple","checkAppleCollision","pop","context","getContext","setTransform","clearRect","window","innerWidth","innerHeight","fillStyle","forEach","x","y","fillRect","role","tabIndex","onKeyDown","e","keyCode","moveSnake","style","border","ref","width","height","onClick","ReactDOM","render","document","getElementById"],"mappings":"oMAAA,IAAMA,EAAc,CAAC,IAAK,KACpBC,EAAc,CAClB,CAAC,EAAG,IAGAC,EAAc,CAAC,EAAG,GAGlBC,EAAa,CACjBC,GAAI,CAAC,GAAI,GACTC,GAAI,CAAC,EAAG,GACRC,GAAI,EAAE,EAAG,GACTC,GAAI,CAAC,EAAG,ICwGKC,EAzGH,WACV,IAAMC,EAAYC,mBADF,EAEUC,mBAASV,GAFnB,mBAETW,EAFS,KAEFC,EAFE,OAGUF,mBAAST,GAHnB,mBAGTY,EAHS,KAGFC,EAHE,OAIMJ,mBAAS,CAAC,GAAI,IAJpB,mBAITK,EAJS,KAIJC,EAJI,OAKUN,mBAAS,MALnB,mBAKTO,EALS,KAKFC,EALE,OAMgBR,oBAAS,GANzB,mBAMTS,EANS,KAMCC,EAND,MCRX,SAAqBC,EAAUC,GACpC,IAAMC,EAAgBd,mBAEtBe,qBAAU,WACRD,EAAcE,QAAUJ,IACvB,CAACA,IAGJG,qBAAU,WAIR,GAAc,OAAVF,EAAgB,CAClB,IAAII,EAAKC,aAJX,WACEJ,EAAcE,YAGaH,GAC3B,OAAO,kBAAMM,cAAcF,OAE5B,CAACJ,IDAJO,EAAY,kBAAMC,MAAYb,GAE9B,IAaMc,EAAc,kBAClBlB,EAAMmB,KAAI,SAACC,EAAIC,GAAL,OAAWC,KAAKC,MAAMD,KAAKE,UAAYtC,EAAYmC,GD7BnD,SC+BNI,EAAiB,SAACC,GAAwB,IAAjBC,EAAgB,uDAAV7B,EAAU,uBAC7C,YAAsB6B,EAAtB,+CAA2B,CAAC,IAAjBC,EAAgB,QACzB,GAAIF,EAAM,KAAOE,EAAQ,IAAMF,EAAM,KAAOE,EAAQ,GAAI,OAAO,GAFpB,kFAI7C,OAAO,GA+BHX,EAAW,WACf,IAAMY,EAAYC,KAAKC,MAAMD,KAAKE,UAAUlC,IACtCmC,EAlBe,SAACA,GAatB,OD/DU,GCmDNA,EAAa,IAAc/C,EAAY,KACzC+C,EAAa,GAAK,GDpDV,GCsDNA,EAAa,IAAc/C,EAAY,KACzC+C,EAAa,GAAK,GAEhBA,EAAa,GAAK,IACpBA,EAAa,GAAK/C,EAAY,GD1DtB,IC4DN+C,EAAa,GAAK,IACpBA,EAAa,GAAK/C,EAAY,GD7DtB,IC+DH+C,EAKcC,CAAe,CAClCL,EAAU,GAAG,GAAK3B,EAAI,GACtB2B,EAAU,GAAG,GAAK3B,EAAI,KAExB2B,EAAUM,QAAQF,GACdR,EAAeQ,KAzDnB5B,EAAS,MACTE,GAAY,IAqBc,SAAC6B,GAC3B,GAAIA,EAAS,GAAG,KAAOpC,EAAM,IAAMoC,EAAS,GAAG,KAAOpC,EAAM,GAAI,CAE9D,IADA,IAAIqC,EAAWnB,IACRO,EAAeY,EAAUD,IAC9BC,EAAWnB,IAGb,OADAjB,EAASoC,IACF,EAET,OAAO,EA2BFC,CAAoBT,IAAYA,EAAUU,MAC/CxC,EAAS8B,IAqBX,OAVAlB,qBAAU,WACR,IAAM6B,EAAU7C,EAAUiB,QAAQ6B,WAAW,MAC7CD,EAAQE,aDxFE,GCwFkB,EAAG,EDxFrB,GCwF+B,EAAG,GAC5CF,EAAQG,UAAU,EAAG,EAAGC,OAAOC,WAAYD,OAAOE,aAClDN,EAAQO,UAAY,QACpBjD,EAAMkD,SAAQ,mCAAEC,EAAF,KAAKC,EAAL,YAAYV,EAAQW,SAASF,EAAGC,EAAG,EAAG,MACpDV,EAAQO,UAAY,UACpBP,EAAQW,SAASnD,EAAM,GAAIA,EAAM,GAAI,EAAG,KACvC,CAACF,EAAOE,EAAOM,IAGhB,yBAAK8C,KAAK,SAASC,SAAS,IAAIC,UAAW,SAACC,GAAD,OA7E3B,SAAC,GAAiB,IAAfC,EAAc,EAAdA,QACJ,IAAXtD,EAAI,KAAwB,IAAZA,EAAI,IAAyB,KAAZsD,GACtB,IAAXtD,EAAI,IAAuB,IAAXA,EAAI,IAAwB,KAAZsD,GACrB,IAAXtD,EAAI,IAAuB,IAAXA,EAAI,IAAwB,KAAZsD,IACpB,IAAZtD,EAAI,IAAwB,IAAXA,EAAI,IAAwB,KAAZsD,GACrCA,GAAW,IAAMA,GAAW,IAAMrD,EAAOd,EAAWmE,IAwEFC,CAAUF,KAC1D,4BACEG,MAAO,CAAEC,OAAQ,mBACjBC,IAAKjE,EACLkE,MAAK,UAAK3E,EAAY,GAAjB,MACL4E,OAAM,UAAK5E,EAAY,GAAjB,QAEPoB,GAAY,2CACb,4BAAQyD,QA3BM,WAChBhE,EAASZ,GACTc,EAASb,GACTe,EAAO,CAAC,GAAI,IACZE,EDjFU,KCkFVE,GAAY,KAsBV,gBE3GNyD,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,W","file":"static/js/main.1c4726b2.chunk.js","sourcesContent":["const CANVAS_SIZE = [800, 800];\nconst SNAKE_START = [\n  [8, 7],\n  //[8, 8],\n];\nconst APPLE_START = [8, 3];\nconst SCALE = 50;\nconst SPEED = 100;\nconst DIRECTIONS = {\n  38: [0, -1], // up\n  40: [0, 1], // down\n  37: [-1, 0], // left\n  39: [1, 0], // right\n};\n\nexport { CANVAS_SIZE, SNAKE_START, APPLE_START, SCALE, SPEED, DIRECTIONS };\n","import React, { useState, useRef, useEffect } from \"react\";\nimport { useInterval } from \"./useInterval\";\nimport {\n  CANVAS_SIZE,\n  SNAKE_START,\n  APPLE_START,\n  SCALE,\n  SPEED,\n  DIRECTIONS,\n} from \"./constants\";\n\nconst App = () => {\n  const canvasRef = useRef();\n  const [snake, setSnake] = useState(SNAKE_START);\n  const [apple, setApple] = useState(APPLE_START);\n  const [dir, setDir] = useState([0, -1]);\n  const [speed, setSpeed] = useState(null);\n  const [gameOver, setGameOver] = useState(false);\n\n  useInterval(() => gameLoop(), speed);\n\n  const endGame = () => {\n    setSpeed(null);\n    setGameOver(true);\n  };\n\n  const moveSnake = ({ keyCode }) => {\n    if (dir[0] === 0 && dir[1] === -1 && keyCode === 40) return;\n    if (dir[0] === 0 && dir[1] === 1 && keyCode === 38) return;\n    if (dir[0] === 1 && dir[1] === 0 && keyCode === 37) return;\n    if (dir[0] === -1 && dir[1] === 0 && keyCode === 39) return;\n    keyCode >= 37 && keyCode <= 40 && setDir(DIRECTIONS[keyCode]);\n  };\n\n  const createApple = () =>\n    apple.map((_a, i) => Math.floor(Math.random() * (CANVAS_SIZE[i] / SCALE)));\n\n  const checkCollision = (piece, snk = snake) => {\n    for (const segment of snk) {\n      if (piece[0] === segment[0] && piece[1] === segment[1]) return true;\n    }\n    return false;\n  };\n\n  const checkAppleCollision = (newSnake) => {\n    if (newSnake[0][0] === apple[0] && newSnake[0][1] === apple[1]) {\n      let newApple = createApple();\n      while (checkCollision(newApple, newSnake)) {\n        newApple = createApple();\n      }\n      setApple(newApple);\n      return true;\n    }\n    return false;\n  };\n\n  const checkSnakeHead = (newSnakeHead) => {\n    if (newSnakeHead[0] * SCALE >= CANVAS_SIZE[0]) {\n      newSnakeHead[0] = 0;\n    }\n    if (newSnakeHead[1] * SCALE >= CANVAS_SIZE[1]) {\n      newSnakeHead[1] = 0;\n    }\n    if (newSnakeHead[0] < 0) {\n      newSnakeHead[0] = CANVAS_SIZE[0] / SCALE;\n    }\n    if (newSnakeHead[1] < 0) {\n      newSnakeHead[1] = CANVAS_SIZE[1] / SCALE;\n    }\n    return newSnakeHead;\n  };\n\n  const gameLoop = () => {\n    const snakeCopy = JSON.parse(JSON.stringify(snake));\n    const newSnakeHead = checkSnakeHead([\n      snakeCopy[0][0] + dir[0],\n      snakeCopy[0][1] + dir[1],\n    ]);\n    snakeCopy.unshift(newSnakeHead);\n    if (checkCollision(newSnakeHead)) endGame();\n    if (!checkAppleCollision(snakeCopy)) snakeCopy.pop();\n    setSnake(snakeCopy);\n  };\n\n  const startGame = () => {\n    setSnake(SNAKE_START);\n    setApple(APPLE_START);\n    setDir([0, -1]);\n    setSpeed(SPEED);\n    setGameOver(false);\n  };\n\n  useEffect(() => {\n    const context = canvasRef.current.getContext(\"2d\");\n    context.setTransform(SCALE, 0, 0, SCALE, 0, 0);\n    context.clearRect(0, 0, window.innerWidth, window.innerHeight);\n    context.fillStyle = \"green\";\n    snake.forEach(([x, y]) => context.fillRect(x, y, 1, 1));\n    context.fillStyle = \"crimson\";\n    context.fillRect(apple[0], apple[1], 1, 1);\n  }, [snake, apple, gameOver]);\n\n  return (\n    <div role=\"button\" tabIndex=\"0\" onKeyDown={(e) => moveSnake(e)}>\n      <canvas\n        style={{ border: \"1px solid black\" }}\n        ref={canvasRef}\n        width={`${CANVAS_SIZE[0]}px`}\n        height={`${CANVAS_SIZE[1]}px`}\n      />\n      {gameOver && <div>GAME OVER!</div>}\n      <button onClick={startGame}>Start Game</button>\n    </div>\n  );\n};\n\nexport default App;\n","// Custom Hook by Dan Abramov\nimport { useEffect, useRef } from \"react\";\n\nexport function useInterval(callback, delay) {\n  const savedCallback = useRef();\n  // Remember the latest callback.\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n\n  // Set up the interval.\n  useEffect(() => {\n    function tick() {\n      savedCallback.current();\n    }\n    if (delay !== null) {\n      let id = setInterval(tick, delay);\n      return () => clearInterval(id);\n    }\n  }, [delay]);\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));"],"sourceRoot":""}